{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Vali Map Definition",
  "type": "object",
  "description": "Configuration for generating maps",
  "required": [
    "countryCodes"
  ],
  "properties": {
    "countryCodes": {
      "type": "array",
      "description": "ISO 3166-1 alpha-2 country codes, or special keywords like 'europe', 'asia', 'africa', 'world', '*', etc.",
      "minItems": 1,
      "uniqueItems": true,
      "items": {
        "type": "string"
      },
      "examples": [
        [
          "NO",
          "SE",
          "DK"
        ],
        [
          "europe"
        ],
        [
          "*"
        ]
      ]
    },
    "subdivisionInclusions": {
      "type": "object",
      "description": "Include only these subdivisions per country (e.g., {\"US\": [\"US-CA\", \"US-NY\"]})",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionExclusions": {
      "type": "object",
      "description": "Exclude these subdivisions per country",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "countryDistribution": {
      "type": "object",
      "description": "Custom distribution weights per country (integers representing relative weights)",
      "additionalProperties": {
        "type": "integer",
        "format": "int32"
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionDistribution": {
      "type": "object",
      "description": "Custom distribution weights per subdivision (outer key = country code, inner key = subdivision code)",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "type": "integer",
          "format": "int32"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "distributionStrategy": {
      "description": "Strategy for distributing locations across regions",
      "$ref": "#/definitions/DistributionStrategy"
    },
    "globalLocationFilter": {
      "type": [
        "null",
        "string"
      ],
      "description": "Expression to filter locations globally. Operators: eq, neq, lt, lte, gt, gte, and, or, +, -, /, *, modulo, in. Properties: ArrowCount, Buildings10, Buildings100, Buildings200, Buildings25, ClosestCoast, ClosestLake, ClosestRailway, ClosestRiver, CountryCode, County, DescriptionLength, DrivingDirectionAngle, Elevation, Heading, HighwayType, HighwayTypeCount, IsResidential, IsScout, Month, ResolutionHeight, Roads0, Roads10, Roads100, Roads200, Roads25, Roads50, SubdivisionCode, Surface, Tunnels10, Tunnels200, WayId, Year. Use $$name to reference named expressions. String literals use single quotes.",
      "examples": [
        "ClosestCoast lt 100 and Buildings200 gte 4",
        "Year gte 2020",
        "Surface eq 'asphalt' or Surface eq 'paved'",
        "HighwayType in ('Primary', 'Secondary', 'Tertiary')"
      ]
    },
    "countryLocationFilters": {
      "type": "object",
      "description": "Per-country location filter expressions (key = country code, value = filter expression)",
      "additionalProperties": {
        "type": "string"
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "countryProximityFilters": {
      "type": "object",
      "description": "Per-country proximity filters (include locations near reference points)",
      "additionalProperties": {
        "$ref": "#/definitions/ProximityFilter"
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "countryGeometryFilters": {
      "type": "object",
      "description": "Per-country geometry filters (GeoJSON polygon inclusion/exclusion)",
      "additionalProperties": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/GeometryFilter"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionLocationFilters": {
      "type": "object",
      "description": "Per-subdivision location filter expressions (outer key = country, inner key = subdivision)",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionProximityFilters": {
      "type": "object",
      "description": "Per-subdivision proximity filters",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/definitions/ProximityFilter"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionGeometryFilters": {
      "type": "object",
      "description": "Per-subdivision geometry filters",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GeometryFilter"
          }
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "globalLocationPreferenceFilters": {
      "type": "array",
      "description": "Percentage-based location allocation filters applied globally. Percentages must sum to 100 or less.",
      "items": {
        "$ref": "#/definitions/LocationPreferenceFilter"
      }
    },
    "countryLocationPreferenceFilters": {
      "type": "object",
      "description": "Per-country percentage-based location allocation filters",
      "additionalProperties": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/LocationPreferenceFilter"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionLocationPreferenceFilters": {
      "type": "object",
      "description": "Per-subdivision percentage-based location allocation filters",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LocationPreferenceFilter"
          }
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "output": {
      "description": "Output configuration for generated locations",
      "$ref": "#/definitions/LocationOutput"
    },
    "proximityFilter": {
      "description": "Global proximity filter (include locations near reference points)",
      "$ref": "#/definitions/ProximityFilter",
      "$comment": "For per-country/subdivision proximity, use countryProximityFilters/subdivisionProximityFilters instead."
    },
    "neighborFilters": {
      "type": "array",
      "description": "Filter locations based on properties of nearby neighbors",
      "items": {
        "$ref": "#/definitions/NeighborFilter"
      }
    },
    "geometryFilters": {
      "type": "array",
      "description": "Filter locations within GeoJSON-defined areas",
      "items": {
        "$ref": "#/definitions/GeometryFilter"
      }
    },
    "namedExpressions": {
      "type": "object",
      "description": "Reusable named filter expressions. Keys must start with $$. Keys must not overlap (e.g., $$urban and $$urban_area would conflict). Reference in filters as $$name.",
      "additionalProperties": {
        "type": "string"
      },
      "examples": [
        {
          "$$urban": "Buildings200 gte 4 and Roads25 gte 2",
          "$$recent": "Year gte 2020"
        }
      ]
    },
    "usedLocationsPaths": {
      "type": "array",
      "description": "Paths to previously generated location JSON files. Locations in these files will be avoided to prevent duplicates.",
      "uniqueItems": true,
      "items": {
        "type": "string"
      }
    },
    "enableDefaultLocationFilters": {
      "type": "boolean",
      "description": "Apply built-in default location filters (e.g., minimum coverage quality)"
    },
    "globalLocationProbability": {
      "description": "Global weight-based location selection probability. Locations matching weight override expressions are more/less likely to be selected.",
      "$ref": "#/definitions/LocationProbability"
    },
    "countryLocationProbabilities": {
      "type": "object",
      "description": "Per-country location selection probability weights",
      "additionalProperties": {
        "$ref": "#/definitions/LocationProbability"
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    },
    "subdivisionLocationProbabilities": {
      "type": "object",
      "description": "Per-subdivision location selection probability weights",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/definitions/LocationProbability"
        }
      },
      "propertyNames": {
        "pattern": "^[A-Z]{2}$"
      }
    }
  },
  "definitions": {
    "DistributionStrategy": {
      "type": "object",
      "properties": {
        "key": {
          "type": [
            "null",
            "string"
          ],
          "description": "Distribution algorithm to use",
          "enum": [
            "FixedCountByMaxMinDistance",
            "MaxCountByFixedMinDistance",
            "EvenlyByDistanceWithinCountry",
            "FixedCountByCoverageDensity"
          ]
        },
        "locationCountGoal": {
          "type": "integer",
          "description": "Target number of locations. Required for FixedCountByMaxMinDistance and FixedCountByCoverageDensity strategies.",
          "format": "int32",
          "minimum": 1.0
        },
        "minMinDistance": {
          "type": "integer",
          "description": "Minimum distance in meters between locations",
          "format": "int32",
          "minimum": 0.0
        },
        "fixedMinDistance": {
          "type": "integer",
          "description": "Fixed minimum distance in meters between locations. Required for MaxCountByFixedMinDistance strategy.",
          "format": "int32",
          "minimum": 1.0
        },
        "treatCountriesAsSingleSubdivision": {
          "type": "array",
          "description": "Country codes to treat as having a single subdivision (skip internal subdivision-level distribution)",
          "items": {
            "type": "string"
          }
        },
        "countryDistributionFromMap": {
          "type": [
            "null",
            "string"
          ],
          "description": "Use country distribution weights from a well-known map",
          "enum": [
            "aarw",
            "aaw",
            "acw",
            "abw",
            "aiw",
            "proworld",
            "aow",
            "rainboltworld",
            "geotime",
            "lerg",
            "amw",
            "yellowbelly",
            "5kable"
          ]
        },
        "coverageDensityTuningFactor": {
          "type": [
            "null",
            "number"
          ],
          "description": "Adjust if lower coverage areas should be upweighted/have lower distance between locations than higher coverage areas. 1 is absurd, 0.01 is almost no adjustment compared to linearly weighted according to number of locations available.",
          "format": "double",
          "default": 0.6,
          "maximum": 1.0,
          "minimum": 0.01
        },
        "coverageDensityClusterSize": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Cluster size for coverage density calculation. 1 ~ 5000x5000 km, 2 ~ 1250x625 km, 3 ~ 156x156 km, 4 ~ 39x20 km, 5 ~ 5x5 km, 6 ~ 1x1 km.",
          "format": "int32",
          "default": 3,
          "maximum": 6.0,
          "minimum": 1.0
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "key": {
                "enum": [
                  "FixedCountByMaxMinDistance"
                ]
              }
            },
            "required": [
              "key"
            ]
          },
          "then": {
            "required": [
              "locationCountGoal"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "key": {
                "enum": [
                  "MaxCountByFixedMinDistance"
                ]
              }
            },
            "required": [
              "key"
            ]
          },
          "then": {
            "required": [
              "fixedMinDistance"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "key": {
                "enum": [
                  "FixedCountByCoverageDensity"
                ]
              }
            },
            "required": [
              "key"
            ]
          },
          "then": {
            "required": [
              "locationCountGoal"
            ]
          }
        }
      ]
    },
    "ProximityFilter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "locationsPath": {
          "type": "string",
          "description": "Path to JSON file containing reference locations"
        },
        "radius": {
          "type": "integer",
          "description": "Include locations within this radius in meters of reference points",
          "format": "int32",
          "maximum": 30000.0,
          "minimum": 1.0
        }
      }
    },
    "GeometryFilter": {
      "type": "object",
      "required": [
        "filePath"
      ],
      "properties": {
        "filePath": {
          "type": "string",
          "description": "Path to GeoJSON file defining the area"
        },
        "inclusionMode": {
          "type": "string",
          "description": "Whether to include or exclude locations in this area. Defaults to 'include'.",
          "default": "include",
          "enum": [
            "include",
            "exclude"
          ]
        },
        "combinationMode": {
          "type": "string",
          "description": "How to combine multiple geometry filters at the same level. All filters at the same level must use the same mode.",
          "enum": [
            "intersection",
            "union"
          ]
        }
      }
    },
    "LocationPreferenceFilter": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "expression"
      ],
      "properties": {
        "expression": {
          "type": "string",
          "description": "Boolean filter expression for matching locations. Use '*' to match all locations.",
          "examples": [
            "Year gte 2020",
            "IsResidential eq true",
            "*"
          ]
        },
        "percentage": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Percentage of total locations that should match this filter (1-100). Percentages across filters at the same level must sum to 100 or less.",
          "format": "int32",
          "maximum": 100.0,
          "minimum": 1.0
        },
        "fill": {
          "type": "boolean",
          "description": "If true, fill remaining allocation with locations matching this filter. Only one filter per level can have fill=true."
        },
        "locationTag": {
          "type": [
            "null",
            "string"
          ],
          "description": "Tag to assign to locations matched by this filter"
        },
        "minMinDistance": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Minimum distance in meters between locations matched by this filter",
          "format": "int32",
          "minimum": 0.0
        },
        "proximityFilter": {
          "$ref": "#/definitions/ProximityFilter"
        },
        "geometryFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GeometryFilter"
          }
        },
        "neighborFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NeighborFilter"
          }
        }
      }
    },
    "NeighborFilter": {
      "type": "object",
      "required": [
        "expression",
        "bound",
        "radius"
      ],
      "properties": {
        "checkEachCardinalDirectionSeparately": {
          "type": "boolean",
          "description": "Check north, south, east, west directions separately"
        },
        "radius": {
          "type": "integer",
          "description": "Radius in meters to check for neighbors",
          "format": "int32",
          "maximum": 5000.0,
          "minimum": 1.0
        },
        "expression": {
          "type": "string",
          "description": "Filter expression for neighbor locations. Use 'current:Property' to reference the current location being evaluated.",
          "examples": [
            "Buildings200 gte 1",
            "current:Surface eq Surface"
          ]
        },
        "limit": {
          "type": [
            "integer",
            "null"
          ],
          "description": "Number or percentage of neighbors required (depends on bound). Not used with 'all'/'none'/'some'.",
          "format": "int32"
        },
        "bound": {
          "type": "string",
          "description": "How many neighbors must match the expression",
          "enum": [
            "gte",
            "lte",
            "all",
            "none",
            "some",
            "percentage-gte",
            "percentage-lte"
          ]
        }
      }
    },
    "LocationOutput": {
      "type": "object",
      "properties": {
        "locationTags": {
          "type": "array",
          "description": "Tags to add to generated locations. Numeric tags can be extended with -<number> for bucketing (e.g., Buildings25-5, ClosestCoast-100).",
          "uniqueItems": true,
          "items": {
            "type": "string",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "ArrowCount",
                  "Buildings10",
                  "Buildings100",
                  "Buildings200",
                  "Buildings25",
                  "ClosestCoast",
                  "ClosestLake",
                  "ClosestRailway",
                  "ClosestRiver",
                  "CountryCode",
                  "County",
                  "DescriptionLength",
                  "DrivingDirectionAngle",
                  "Elevation",
                  "Heading",
                  "HighwayType",
                  "HighwayTypeCount",
                  "IsResidential",
                  "IsScout",
                  "Month",
                  "ResolutionHeight",
                  "Roads0",
                  "Roads10",
                  "Roads100",
                  "Roads200",
                  "Roads25",
                  "Roads50",
                  "Season",
                  "SubdivisionCode",
                  "Surface",
                  "Tunnels10",
                  "Tunnels200",
                  "WayId",
                  "Year",
                  "YearMonth"
                ]
              },
              {
                "type": "string",
                "pattern": "^(ArrowCount|Buildings10|Buildings100|Buildings200|Buildings25|ClosestCoast|ClosestLake|ClosestRailway|ClosestRiver|DescriptionLength|DrivingDirectionAngle|Elevation|Heading|HighwayTypeCount|Month|ResolutionHeight|Roads0|Roads10|Roads100|Roads200|Roads25|Roads50|Tunnels10|Tunnels200|Year)-\\d+$"
              }
            ]
          }
        },
        "panoIdCountryCodes": {
          "type": "array",
          "description": "Country codes for which to look up specific panorama IDs during verification",
          "uniqueItems": true,
          "items": {
            "type": "string"
          }
        },
        "globalHeadingExpression": {
          "type": [
            "null",
            "string"
          ],
          "description": "Expression to calculate heading for all locations",
          "examples": [
            "DrivingDirectionAngle",
            "DrivingDirectionAngle + 90",
            "DrivingDirectionAngle + 180"
          ]
        },
        "countryHeadingExpressions": {
          "type": "object",
          "description": "Per-country heading expressions (key = country code, value = heading expression)",
          "additionalProperties": {
            "type": "string"
          },
          "propertyNames": {
            "pattern": "^[A-Z]{2}$"
          }
        },
        "globalZoom": {
          "type": [
            "null",
            "number"
          ],
          "description": "Zoom level for all locations (0-3.6)",
          "format": "double",
          "maximum": 3.6,
          "minimum": 0.0
        },
        "globalPitch": {
          "type": [
            "null",
            "number"
          ],
          "description": "Pitch angle for all locations (-90 to 90)",
          "format": "double",
          "maximum": 90.0,
          "minimum": -90.0
        },
        "panoVerificationStrategy": {
          "type": [
            "null",
            "string"
          ],
          "description": "Strategy for selecting panorama IDs",
          "enum": [
            "Newest",
            "Random",
            "RandomNotNewest",
            "RandomAvoidNewest",
            "RandomNotOldest",
            "RandomAvoidOldest",
            "SecondNewest",
            "Oldest",
            "SecondOldest",
            "YearMonthPeriod"
          ]
        },
        "countryPanoVerificationPanning": {
          "type": "object",
          "description": "Per-country panning configuration for panorama verification (key = country code)",
          "additionalProperties": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/definitions/CountryPanning"
              }
            ]
          },
          "propertyNames": {
            "pattern": "^[A-Z]{2}$"
          }
        },
        "panoVerificationExpression": {
          "type": [
            "null",
            "string"
          ],
          "description": "Filter expression applied during panorama verification"
        },
        "panoVerificationParallelism": {
          "type": "integer",
          "description": "Number of parallel panorama verification requests",
          "format": "int32",
          "default": 100,
          "minimum": 1.0
        },
        "panoVerificationStart": {
          "type": [
            "null",
            "string"
          ],
          "description": "Start date for panorama verification (format: YYYY-MM-DD)",
          "format": "date"
        },
        "panoVerificationEnd": {
          "type": [
            "null",
            "string"
          ],
          "description": "End date for panorama verification (format: YYYY-MM-DD)",
          "format": "date"
        }
      }
    },
    "CountryPanning": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "defaultPanning": {
          "type": "string",
          "description": "Default panning heading expression for this country"
        },
        "panningExpressions": {
          "type": "array",
          "description": "Conditional panning expressions. First matching expression is used, then falls back to defaultPanning.",
          "items": {
            "$ref": "#/definitions/PanningExpression"
          }
        }
      }
    },
    "PanningExpression": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "expression",
        "panning"
      ],
      "properties": {
        "expression": {
          "type": "string",
          "description": "Boolean filter expression to match locations"
        },
        "panning": {
          "type": "string",
          "description": "Heading expression to use when this condition matches"
        }
      }
    },
    "LocationProbability": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "defaultWeight": {
          "type": "integer",
          "description": "Default weight for locations not matching any override. Must be greater than 0 when weight overrides are used.",
          "format": "int32",
          "minimum": 1.0
        },
        "weightOverrides": {
          "type": "array",
          "description": "Weight overrides based on filter expressions. Locations matching an expression use that weight instead of defaultWeight.",
          "items": {
            "$ref": "#/definitions/LocationWeightOverride"
          }
        }
      }
    },
    "LocationWeightOverride": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "expression",
        "weight"
      ],
      "properties": {
        "expression": {
          "type": "string",
          "description": "Boolean filter expression to match locations"
        },
        "weight": {
          "type": "integer",
          "description": "Selection weight for matched locations (higher = more likely). Must be greater than 0.",
          "format": "int32",
          "minimum": 1.0
        }
      }
    }
  }
}